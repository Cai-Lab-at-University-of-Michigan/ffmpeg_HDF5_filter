name: Build and publish project

on:
  push:
    branches: [main, master]
    tags: ['v*']
  pull_request:
    branches: [main, master]
  workflow_dispatch:  # Allow manual triggering

jobs:
  # ================= BUILD FFMPEG LIBRARIES =================
  build_ffmpeg:
    name: Build FFmpeg libraries
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-22.04, windows-2022, macos-12]
    steps:
      - uses: actions/checkout@v3
        with:
          submodules: recursive

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install dependencies
        shell: bash
        run: |
          chmod +x scripts/install_dependencies.sh
          ./scripts/install_dependencies.sh

      - name: Cache FFmpeg Dependencies
        uses: actions/cache@v3
        with:
          path: ffmpeg_build
          key: ${{ runner.os }}-ffmpeg-${{ hashFiles('scripts/build_ffmpeg.sh', 'scripts/build_ffmpeg_win.sh') }}
          restore-keys: |
            ${{ runner.os }}-ffmpeg-

      - name: Build FFmpeg
        shell: bash
        run: |
          if [ "$RUNNER_OS" == "Windows" ]; then
            chmod +x scripts/build_ffmpeg_win.sh
            ./scripts/build_ffmpeg_win.sh
          else
            chmod +x scripts/build_ffmpeg.sh
            ./scripts/build_ffmpeg.sh
          fi

      - name: Upload FFmpeg artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ffmpeg-${{ runner.os }}
          path: ffmpeg_build/
          retention-days: 7

  # ================= BUILD PYTHON WHEELS =================
  build_wheels:
    name: Build wheels on ${{ matrix.os }} for ${{ matrix.python }}
    needs: build_ffmpeg
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-22.04, windows-2022, macos-12]
        python: ['cp39', 'cp310', 'cp311', 'cp312']

    steps:
      - uses: actions/checkout@v3
        with:
          submodules: recursive

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          python -m pip install cibuildwheel setuptools wheel

      - name: Download FFmpeg artifacts
        uses: actions/download-artifact@v3
        with:
          name: ffmpeg-${{ runner.os }}
          path: ffmpeg_build

      - name: Setup environment
        run: |
          echo "FFMPEG_ROOT=${{ github.workspace }}/ffmpeg_build" >> $GITHUB_ENV
          # Make FFmpeg binaries executable (Linux/macOS)
          if [ "$RUNNER_OS" != "Windows" ]; then
            chmod -R +x ${{ github.workspace }}/ffmpeg_build/bin
          fi
        shell: bash

      - name: List FFmpeg artifacts
        shell: bash
        run: |
          if [ "$RUNNER_OS" == "Windows" ]; then
            ls -la ffmpeg_build/bin
            ls -la ffmpeg_build/lib || echo "No lib directory"
            ls -la ffmpeg_build/include || echo "No include directory"
          else
            find ffmpeg_build -type f -name "*.so*" -o -name "*.dylib" -o -name "*.dll" | sort
            find ffmpeg_build/include -type f -name "*.h" | head -5
          fi

      - name: Install system dependencies
        shell: bash
        run: |
          if [ "$RUNNER_OS" == "Linux" ]; then
            sudo apt-get update
            sudo apt-get install -y libhdf5-dev patchelf
          elif [ "$RUNNER_OS" == "macOS" ]; then
            brew install hdf5 pkg-config
          elif [ "$RUNNER_OS" == "Windows" ]; then
            python -m pip install delvewheel
          fi

      - name: Build wheels
        run: |
          python -m cibuildwheel --output-dir wheelhouse
        env:
          CIBW_BUILD: "${{ matrix.python }}-*"
          CIBW_SKIP: "*-musllinux* *-win32 *-manylinux_i686"
          
          # For manylinux: install HDF5 development headers and copy FFmpeg
          CIBW_BEFORE_ALL_LINUX: >
            yum install -y epel-release && 
            yum install -y hdf5-devel patchelf && 
            mkdir -p /usr/local/ffmpeg && 
            cp -r ${FFMPEG_ROOT}/* /usr/local/ffmpeg/
          
          # For macOS wheels: ensure dynamic libraries are properly linked
          CIBW_BEFORE_ALL_MACOS: >
            brew install hdf5 pkg-config && 
            mkdir -p /usr/local/ffmpeg && 
            cp -r ${FFMPEG_ROOT}/* /usr/local/ffmpeg/

          # For Windows wheels: prepare environment
          CIBW_BEFORE_ALL_WINDOWS: >
            mkdir -p C:/ffmpeg && 
            cp -r ${FFMPEG_ROOT}/* C:/ffmpeg/
          
          # Wheel repair commands
          CIBW_REPAIR_WHEEL_COMMAND_LINUX: auditwheel repair -w {dest_dir} {wheel}
          CIBW_REPAIR_WHEEL_COMMAND_MACOS: >
            DYLD_LIBRARY_PATH=${FFMPEG_ROOT}/lib delocate-listdeps {wheel} &&
            DYLD_LIBRARY_PATH=${FFMPEG_ROOT}/lib delocate-wheel --require-archs x86_64 -w {dest_dir} {wheel}
          CIBW_REPAIR_WHEEL_COMMAND_WINDOWS: delvewheel repair -w {dest_dir} {wheel}
          
          # Custom environment variables for setup.py
          CIBW_ENVIRONMENT_LINUX: >
            FFMPEG_ROOT=/usr/local/ffmpeg 
            PKG_CONFIG_PATH=/usr/local/ffmpeg/lib/pkgconfig:$PKG_CONFIG_PATH 
            LD_LIBRARY_PATH=/usr/local/ffmpeg/lib:$LD_LIBRARY_PATH
            PATH=/usr/local/ffmpeg/bin:$PATH
          
          CIBW_ENVIRONMENT_MACOS: >
            FFMPEG_ROOT=/usr/local/ffmpeg 
            PKG_CONFIG_PATH=/usr/local/ffmpeg/lib/pkgconfig:$PKG_CONFIG_PATH 
            DYLD_LIBRARY_PATH=/usr/local/ffmpeg/lib:$DYLD_LIBRARY_PATH
            PATH=/usr/local/ffmpeg/bin:$PATH
          
          CIBW_ENVIRONMENT_WINDOWS: >
            FFMPEG_ROOT=C:/ffmpeg 
            PKG_CONFIG_PATH=C:/ffmpeg/lib/pkgconfig 
            PATH=C:/ffmpeg/bin;$PATH
          
          # Test wheel installation and importing
          CIBW_TEST_REQUIRES: pytest numpy
          CIBW_TEST_COMMAND: pytest {package}/tests/basic_test.py -v

      # Extract shared objects from wheel for Java to use
      - name: Extract shared libraries from wheels
        shell: bash
        run: |
          mkdir -p native_libs/${{ runner.os }}
          
          if [ "$RUNNER_OS" == "Linux" ]; then
            # Extract .so files from the wheel
            python -c "
            import zipfile, os, glob, shutil
            wheels = glob.glob('wheelhouse/*.whl')
            if wheels:
                with zipfile.ZipFile(wheels[0]) as wheel:
                    so_files = [f for f in wheel.namelist() if f.endswith('.so')]
                    for so_file in so_files:
                        wheel.extract(so_file, 'extracted_wheel')
                        # Move to native_libs directory
                        os.makedirs('native_libs/Linux', exist_ok=True)
                        shutil.copy(f'extracted_wheel/{so_file}', 'native_libs/Linux/')
            "
          elif [ "$RUNNER_OS" == "macOS" ]; then
            # Extract .dylib files from the wheel
            python -c "
            import zipfile, os, glob, shutil
            wheels = glob.glob('wheelhouse/*.whl')
            if wheels:
                with zipfile.ZipFile(wheels[0]) as wheel:
                    dylib_files = [f for f in wheel.namelist() if f.endswith('.dylib')]
                    for dylib_file in dylib_files:
                        wheel.extract(dylib_file, 'extracted_wheel')
                        # Move to native_libs directory
                        os.makedirs('native_libs/macOS', exist_ok=True)
                        shutil.copy(f'extracted_wheel/{dylib_file}', 'native_libs/macOS/')
            "
          elif [ "$RUNNER_OS" == "Windows" ]; then
            # Extract .dll files from the wheel
            python -c "
            import zipfile, os, glob, shutil
            wheels = glob.glob('wheelhouse/*.whl')
            if wheels:
                with zipfile.ZipFile(wheels[0]) as wheel:
                    dll_files = [f for f in wheel.namelist() if f.endswith('.dll')]
                    for dll_file in dll_files:
                        wheel.extract(dll_file, 'extracted_wheel')
                        # Move to native_libs directory
                        os.makedirs('native_libs/Windows', exist_ok=True)
                        shutil.copy(f'extracted_wheel/{dll_file}', 'native_libs/Windows/')
            "
          fi
          
          # List extracted libraries
          find native_libs -type f | sort

      - name: Upload native libraries
        uses: actions/upload-artifact@v4
        with:
          name: native-libs-${{ runner.os }}-${{ matrix.python }}
          path: native_libs/
          retention-days: 7

      - name: Upload wheels
        uses: actions/upload-artifact@v4
        with:
          path: ./wheelhouse/*.whl
          name: wheels-${{ runner.os }}-${{ matrix.python }}
          retention-days: 7

  # ================= BUILD SOURCE DISTRIBUTION =================
  build_sdist:
    name: Build source distribution
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          submodules: recursive

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Build sdist
        run: |
          python -m pip install --upgrade pip build setuptools wheel
          python -m build --sdist

      - name: Upload sdist
        uses: actions/upload-artifact@v4
        with:
          path: ./dist/*.tar.gz
          name: sdist
          retention-days: 7

  # ================= BUILD JAVA LIBRARY =================
  build_java:
    name: Build Java library
    # Now depends on build_wheels instead of directly on build_ffmpeg
    needs: build_wheels
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up JDK 8
        uses: actions/setup-java@v3
        with:
          java-version: '8'
          distribution: 'temurin'
      
      # Download both FFmpeg artifacts and the native libraries extracted from wheels
      - name: Download FFmpeg artifacts from all platforms
        uses: actions/download-artifact@v3
        with:
          path: downloads/
      
      - name: Prepare native library structure
        run: |
          # Create native libs directory structure
          mkdir -p native_libs/linux native_libs/windows native_libs/macos
          
          # Copy libraries from the wheel extractions (prioritize these)
          find downloads/native-libs-* -type f -name "*.so" -exec cp {} native_libs/linux/ \;
          find downloads/native-libs-* -type f -name "*.dll" -exec cp {} native_libs/windows/ \;
          find downloads/native-libs-* -type f -name "*.dylib" -exec cp {} native_libs/macos/ \;
          
          # List what we have from wheels
          echo "Libraries extracted from Python wheels:"
          find native_libs -type f | sort
          
          # Copy prepare_native_libs.sh to the workspace and make it executable
          cp scripts/prepare_native_libs.sh ./prepare_native_libs.sh
          chmod +x ./prepare_native_libs.sh
          
          # Run the updated script
          ./prepare_native_libs.sh
      
      - name: Setup Gradle and build JAR
        uses: gradle/gradle-build-action@v2
        with:
          build-root-directory: imagej-hdf5-wrapper
          arguments: packJar
      
      - name: Upload JAR
        uses: actions/upload-artifact@v4
        with:
          name: hdf5-ffmpeg-jar
          path: imagej-hdf5-wrapper/build/libs/HDF5-ffmpeg-*.jar

  # ================= PUBLISH PACKAGES =================
  publish:
    name: Publish to PyPI and GitHub Releases
    needs: [build_wheels, build_sdist, build_java]
    runs-on: ubuntu-latest
    # Only publish to PyPI on tags or manually triggered builds
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v') || github.event_name == 'workflow_dispatch'
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      
      - name: Download all wheels and sdist
        run: |
          python -m pip install --upgrade pip twine
          mkdir -p dist
      
      - name: Download wheels
        uses: actions/download-artifact@v3
        with:
          path: dist/
          pattern: wheels-*
          merge-multiple: true
      
      - name: Download sdist
        uses: actions/download-artifact@v3
        with:
          name: sdist
          path: dist/
      
      - name: Download Java JAR
        uses: actions/download-artifact@v3
        with:
          name: hdf5-ffmpeg-jar
          path: java-dist/
      
      - name: Check distribution files
        run: |
          find dist -type f -name "*.whl" -o -name "*.tar.gz" | sort
          python -m twine check dist/*.whl dist/*.tar.gz
      
      - name: Publish to TestPyPI
        # Always publish to TestPyPI for verification
        env:
          TWINE_USERNAME: ${{ secrets.TESTPYPI_USERNAME }}
          TWINE_PASSWORD: ${{ secrets.TESTPYPI_PASSWORD }}
        run: python -m twine upload --repository testpypi dist/*.whl dist/*.tar.gz
      
      - name: Publish to PyPI
        # Only publish to real PyPI for tagged releases
        if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')
        env:
          TWINE_USERNAME: ${{ secrets.PYPI_USERNAME }}
          TWINE_PASSWORD: ${{ secrets.PYPI_PASSWORD }}
        run: python -m twine upload dist/*.whl dist/*.tar.gz
      
      # For testing: Delete previous snapshot releases to avoid cluttering GitHub releases
      - name: Delete previous snapshot release
        if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
        uses: dev-drprasad/delete-tag-and-release@v0.2.1
        with:
          tag_name: snapshot-${{ github.ref_name }}
          delete_release: true
          repo: ${{ github.repository }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Get timestamp for snapshot version
        id: timestamp
        if: github.event_name == 'push' && !startsWith(github.ref, 'refs/tags/')
        run: echo "timestamp=$(date +'%Y%m%d%H%M%S')" >> $GITHUB_OUTPUT
      
      # Modified to upload JAR for both tagged releases and snapshots
      - name: Upload JAR to GitHub release
        if: github.event_name == 'push' && (startsWith(github.ref, 'refs/tags/v') || github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
        uses: softprops/action-gh-release@v1
        with:
          files: java-dist/HDF5-ffmpeg-*.jar
          # For snapshots, create a special release named after the branch and commit
          tag_name: ${{ startsWith(github.ref, 'refs/tags/') && github.ref_name || format('snapshot-{0}', github.ref_name) }}
          name: ${{ startsWith(github.ref, 'refs/tags/') && github.ref_name || format('Snapshot {0} ({1})', github.ref_name, steps.timestamp.outputs.timestamp) }}
          prerelease: ${{ !startsWith(github.ref, 'refs/tags/') }}
          # Automatically replace existing snapshots from the same branch
          draft: false
          # If it's a snapshot, mark it as a development build
          body: ${{ !startsWith(github.ref, 'refs/tags/') && format('Development build from {0} branch, commit {1} created at {2}', github.ref_name, github.sha, steps.timestamp.outputs.timestamp) || '' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}